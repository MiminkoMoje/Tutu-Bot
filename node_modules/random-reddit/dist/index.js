"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RandomReddit = void 0;
const reddit_wrapper_v2_1 = __importDefault(require("reddit-wrapper-v2"));
const utils_1 = require("./utils");
const { version } = require('../package.json');
/**
 * Reddit's random class for random posts
 *
 * Usage:
 * 1. Create the instance of this class and pass the Reddit credentials in the constructor
 * 2. Use `getPost()` or `getImage()` method from your instance
 */
class RandomReddit {
    /**
     * Creates new RandomReddit instance
     * @param params - Reddit credentials. They go straigt to the reddit api wrapper
     * @see https://github.com/Javin-Ambridge/reddit-wrapper#reddit-api-options
     */
    constructor(params) {
        /** whether or not the debug mode is enabled */
        this._canLog = false;
        this._reddit = reddit_wrapper_v2_1.default({
            user_agent: `${process.platform}:random-posts-:${version} (by /u/mamoru-kun)`,
            retry_on_wait: true,
            retry_on_server_error: 5,
            retry_delay: 5,
            logs: false,
            ...params
        }).api;
        this._canLog = (params === null || params === void 0 ? void 0 : params.logs) || false;
    }
    /**
     * Returns the random post from specified subreddit
     * @param subreddit - subreddit name (without `r/` part)
     */
    async getPost(subreddit, retryLimit = 10) {
        var _a, _b, _c, _d;
        const pickedSub = Array.isArray(subreddit) ? utils_1.getRandomItemFrom(subreddit) : subreddit;
        const [, response] = await this._get(`/r/${pickedSub}/random?count=50`, retryLimit);
        const children = Array.isArray(response) ? (_b = (_a = response[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.children : (_c = response === null || response === void 0 ? void 0 : response.data) === null || _c === void 0 ? void 0 : _c.children;
        return (_d = utils_1.getRandomItemFrom(children || [])) !== null && _d !== void 0 ? _d : null;
    }
    /**
     * Returns the image from random post from specified subreddit.
     * If the post doesn't have the image - repeats the request until it contains the image
     * @param subreddit - subreddit name (without `r/` part)
     */
    async getImage(subreddit, retryLimit = 10) {
        var _a;
        let retries = 0;
        let post;
        while (retries < retryLimit) {
            post = await this.getPost(subreddit);
            const hasImageURL = /(jpe?g|png|gif)/.test((_a = post === null || post === void 0 ? void 0 : post.data) === null || _a === void 0 ? void 0 : _a.url);
            if (hasImageURL) {
                break;
            }
            retries += 1;
            if (retries === retryLimit) {
                throw new utils_1.ExceededRetriesError('No image URL found! Request retries limits exceeded!');
            }
            //this._canLog && console.warn("[random-reddit] No image URL found! Repeating the process...");
        }
        if (post.data.is_gallery) {
            return RandomReddit._getRandomImageFromGallery(post);
        }
        exports.title = post.data.title
        exports.author = `u/${post.data.author}`
        exports.subreddit = post.data.subreddit_name_prefixed
        // here can be imgur `gifv` links sometimes, they have to be replaced w/ `gif` ones
        return post.data.url.replace('gifv', 'gif');
    }
    /**
     * Returns a specific post with given ID from specified subreddit
     * @param subreddit - subreddit name
     * @param id - id (ID36) of the post
     * @param retryLimit - maximum amount of possible retries
     */
    async getPostById(id, subreddit, retryLimit = 10) {
        var _a, _b, _c, _d;
        const [, response] = await this._get(`/r/${subreddit}/comments/${id}`, retryLimit);
        console.log(response);
        return (_d = (_c = (_b = (_a = response[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.children[0]) === null || _c === void 0 ? void 0 : _c.data) !== null && _d !== void 0 ? _d : null;
    }
    /**
     * Returns an image from given post's gallery
     * @param post - reddit post
     */
    static _getRandomImageFromGallery(post) {
        const validPosts = Object.values(post.media_metadata).filter((image) => image.status === 'valid');
        const item = utils_1.getRandomItemFrom(validPosts);
        return item.s.u.replace(/\&amp\;/g, '&');
    }
    async _get(endpoint, retryLimit = 10) {
        let retries = 0;
        while (retries < retryLimit) {
            this._canLog && console.log(`Trying to GET ${endpoint}. Retries: 0`);
            let response;
            try {
                response = await this._reddit.get(endpoint);
            }
            catch (error) {
                throw error;
            }
            switch (response === null || response === void 0 ? void 0 : response[0]) {
                case 200: // OK
                    return response;
                case undefined: // if Reddit-wrapper-v2 gets 403 error two times in a row, it doesn't throw any errors - it just returns undefined
                case 403: // Access forbidden
                    throw new Error('Access denied to Reddit API!');
            }
            retries += 1;
            if (this._canLog && retries !== retryLimit) {
                console.warn(`Failed to GET ${endpoint}. Retrying`);
            }
        }
        throw new utils_1.ExceededRetriesError();
    }
}
exports.RandomReddit = RandomReddit;
//# sourceMappingURL=index.js.map